# Task 004: EventParticipateのリファクタリング

## 概要
EventParticipateコンポーネントをテスタブルな設計にリファクタリングする。
複雑な状態管理とServer Actions呼び出しをカスタムフックに抽出し、UIとロジックを分離する。

## 作業内容

### 1. useEventParticipationフックの改善
- 既存のuseEventParticipationV2を基に改善
- NavigationProvider/ActionsProviderの活用
- テスト可能な構造への変更

### 2. Presentationalコンポーネントの作成
- スケジュール入力UI
- 参加者情報入力UI
- 純粋なコンポーネント化

### 3. Containerコンポーネントの作成
- ビジネスロジックの管理
- フックとPresentationalの接続

### 4. サブコンポーネントの整理
- ParticipantInfoForm
- ScheduleSelector
- SubmitButton

### 5. テストの書き直し
- act warning の解消
- モックを使わない統合テスト

## 実装詳細

### 改善されたuseEventParticipationフック（src/lib/hooks/use-event-participation.ts）
```typescript
import { useState, useCallback, useEffect, useRef } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { useActions } from "@/lib/providers/actions";
import { useNavigation } from "@/lib/providers/navigation";
import { useAuth } from "@/lib/auth/hooks";
import { useTranslation } from "react-i18next";
import type { Event } from "@/lib/effects/services/event/schemas";
import type { ParticipantInfo } from "@/lib/effects/services/schedule/schemas";

interface EventParticipationOptions {
  event: Event;
  locale: string;
  onSuccess?: () => void;
  autoSaveDelay?: number;
}

export function useEventParticipation({
  event,
  locale,
  onSuccess,
  autoSaveDelay = 3000,
}: EventParticipationOptions) {
  const { t } = useTranslation("schedule");
  const actions = useActions();
  const navigation = useNavigation();
  const { user } = useAuth();
  
  // 状態管理
  const [selectedSlots, setSelectedSlots] = useState<Set<string>>(new Set());
  const [participantInfo, setParticipantInfo] = useState<ParticipantInfo>({
    name: user?.name || "",
    email: user?.email || "",
  });
  const [showSavedIndicator, setShowSavedIndicator] = useState(false);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  
  // タイマー管理
  const autoSaveTimerRef = useRef<NodeJS.Timeout | null>(null);
  const savedIndicatorTimerRef = useRef<NodeJS.Timeout | null>(null);
  
  // 既存スケジュールの取得
  const { data: existingSchedule, isLoading } = useQuery({
    queryKey: ["schedule", "existing", event.id, user?.id],
    queryFn: async () => {
      // 実装詳細...
      return null;
    },
    enabled: !!user,
  });
  
  // スケジュール保存のミューテーション
  const saveMutation = useMutation({
    mutationFn: async (isAutoSave = false) => {
      if (!isAutoSave && selectedSlots.size === 0) {
        throw new Error(t("participate.selectTimeSlot"));
      }
      
      if (!user && (!participantInfo.name || !participantInfo.email)) {
        throw new Error(t("participate.enterNameAndEmail"));
      }
      
      const slots = Array.from(selectedSlots);
      return actions.schedule.submit({
        eventId: event.id,
        slots,
        participantInfo: user ? undefined : participantInfo,
      });
    },
    onSuccess: (result) => {
      if (result.success) {
        setHasUnsavedChanges(false);
        setShowSavedIndicator(true);
        
        // 3秒後に保存済み表示を消す
        if (savedIndicatorTimerRef.current) {
          clearTimeout(savedIndicatorTimerRef.current);
        }
        savedIndicatorTimerRef.current = setTimeout(() => {
          setShowSavedIndicator(false);
        }, 3000);
        
        onSuccess?.();
      }
    },
  });
  
  // スロット選択の処理
  const handleSlotToggle = useCallback((slotId: string) => {
    setSelectedSlots(prev => {
      const newSet = new Set(prev);
      if (newSet.has(slotId)) {
        newSet.delete(slotId);
      } else {
        newSet.add(slotId);
      }
      return newSet;
    });
    setHasUnsavedChanges(true);
    
    // 自動保存のタイマーをリセット
    if (autoSaveTimerRef.current) {
      clearTimeout(autoSaveTimerRef.current);
    }
    autoSaveTimerRef.current = setTimeout(() => {
      saveMutation.mutate(true);
    }, autoSaveDelay);
  }, [autoSaveDelay, saveMutation]);
  
  // クリーンアップ
  useEffect(() => {
    return () => {
      if (autoSaveTimerRef.current) {
        clearTimeout(autoSaveTimerRef.current);
      }
      if (savedIndicatorTimerRef.current) {
        clearTimeout(savedIndicatorTimerRef.current);
      }
    };
  }, []);
  
  return {
    // 状態
    selectedSlots,
    participantInfo,
    isLoading,
    isSubmitting: saveMutation.isPending,
    showSavedIndicator,
    hasUnsavedChanges,
    error: saveMutation.error?.message || null,
    
    // アクション
    handleSlotToggle,
    updateParticipantInfo: setParticipantInfo,
    handleSubmit: () => saveMutation.mutate(false),
    handleCancel: () => navigation.back(),
  };
}
```

### Presentationalコンポーネント（src/components/events/EventParticipatePresentation.tsx）
```typescript
import { Paper, Stack, Alert, Title, Text, Group } from "@mantine/core";
import { IconCalendar } from "@tabler/icons-react";
import { ScheduleSelector } from "./ScheduleSelector";
import { ParticipantInfoForm } from "./ParticipantInfoForm";
import { SubmitButtons } from "./SubmitButtons";
import type { Event } from "@/lib/effects/services/event/schemas";

interface EventParticipatePresentationProps {
  readonly event: Event;
  readonly selectedSlots: Set<string>;
  readonly participantInfo: ParticipantInfo;
  readonly isAuthenticated: boolean;
  readonly isSubmitting: boolean;
  readonly showSavedIndicator: boolean;
  readonly hasUnsavedChanges: boolean;
  readonly error: string | null;
  readonly onSlotToggle: (slotId: string) => void;
  readonly onParticipantInfoChange: (info: ParticipantInfo) => void;
  readonly onSubmit: () => void;
  readonly onCancel: () => void;
  readonly t: (key: string) => string;
}

export function EventParticipatePresentation({
  event,
  selectedSlots,
  participantInfo,
  isAuthenticated,
  isSubmitting,
  showSavedIndicator,
  hasUnsavedChanges,
  error,
  onSlotToggle,
  onParticipantInfoChange,
  onSubmit,
  onCancel,
  t,
}: EventParticipatePresentationProps) {
  return (
    <Stack gap="lg">
      {/* イベント情報 */}
      <Paper shadow="sm" p="lg">
        <Group>
          <IconCalendar size={24} />
          <div>
            <Title order={3}>{event.name}</Title>
            {event.description && (
              <Text size="sm" c="dimmed">{event.description}</Text>
            )}
          </div>
        </Group>
      </Paper>
      
      {/* エラー表示 */}
      {error && (
        <Alert color="red">
          {error}
        </Alert>
      )}
      
      {/* 参加者情報入力（非認証時のみ） */}
      {!isAuthenticated && (
        <ParticipantInfoForm
          participantInfo={participantInfo}
          onChange={onParticipantInfoChange}
          disabled={isSubmitting}
          t={t}
        />
      )}
      
      {/* スケジュール選択 */}
      <ScheduleSelector
        event={event}
        selectedSlots={selectedSlots}
        onSlotToggle={onSlotToggle}
        disabled={isSubmitting}
        showSavedIndicator={showSavedIndicator}
        t={t}
      />
      
      {/* 送信ボタン */}
      <SubmitButtons
        onSubmit={onSubmit}
        onCancel={onCancel}
        isSubmitting={isSubmitting}
        hasUnsavedChanges={hasUnsavedChanges}
        t={t}
      />
    </Stack>
  );
}
```

### テスト（src/components/events/EventParticipate.test.tsx）
```typescript
import { describe, it, expect, vi } from "vitest";
import { screen, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { renderWithProviders } from "@/test/providers";
import { EventFactory } from "@/test/factories/event";
import { setupAuth } from "@/test/helpers";
import { EventParticipateContainer } from "./EventParticipateContainer";

describe("EventParticipate", () => {
  const mockEvent = EventFactory.create();
  
  it("非認証ユーザーの場合、参加者情報入力欄を表示", async () => {
    setupAuth(null); // 非認証状態
    
    renderWithProviders(
      <EventParticipateContainer 
        event={mockEvent}
        params={Promise.resolve({ locale: "ja", id: "event123" })}
      />
    );
    
    await waitFor(() => {
      expect(screen.getByLabelText("名前")).toBeInTheDocument();
      expect(screen.getByLabelText("メールアドレス")).toBeInTheDocument();
    });
  });
  
  it("時間枠を選択して送信できる", async () => {
    const user = userEvent.setup();
    const mockSubmit = vi.fn().mockResolvedValue({
      success: true,
      data: { scheduleId: "schedule123" },
    });
    const mockBack = vi.fn();
    
    renderWithProviders(
      <EventParticipateContainer 
        event={mockEvent}
        params={Promise.resolve({ locale: "ja", id: "event123" })}
      />,
      {
        actions: {
          schedule: { submit: mockSubmit },
        },
        navigation: { back: mockBack },
      }
    );
    
    // 時間枠を選択
    await user.click(screen.getByTestId("slot-2024-03-01-09:00"));
    
    // 参加者情報を入力（非認証の場合）
    await user.type(screen.getByLabelText("名前"), "山田太郎");
    await user.type(screen.getByLabelText("メールアドレス"), "yamada@example.com");
    
    // 送信
    await user.click(screen.getByRole("button", { name: "送信" }));
    
    await waitFor(() => {
      expect(mockSubmit).toHaveBeenCalledWith({
        eventId: "event123",
        slots: ["2024-03-01T09:00"],
        participantInfo: {
          name: "山田太郎",
          email: "yamada@example.com",
        },
      });
      expect(mockBack).toHaveBeenCalled();
    });
  });
  
  it("自動保存が動作する", async () => {
    const user = userEvent.setup();
    const mockSubmit = vi.fn().mockResolvedValue({
      success: true,
      data: { scheduleId: "schedule123" },
    });
    
    setupAuth(); // 認証済み
    
    renderWithProviders(
      <EventParticipateContainer 
        event={mockEvent}
        params={Promise.resolve({ locale: "ja", id: "event123" })}
      />,
      {
        actions: {
          schedule: { submit: mockSubmit },
        },
      }
    );
    
    // 時間枠を選択
    await user.click(screen.getByTestId("slot-2024-03-01-09:00"));
    
    // 自動保存を待つ（3秒後）
    await waitFor(() => {
      expect(mockSubmit).toHaveBeenCalledWith(
        expect.objectContaining({
          eventId: "event123",
          slots: ["2024-03-01T09:00"],
        })
      );
    }, { timeout: 4000 });
    
    // 保存済み表示を確認
    expect(screen.getByText("保存済み")).toBeInTheDocument();
  });
});
```

## 受け入れ条件
- [ ] useEventParticipationフックが改善されている
- [ ] Presentational/Container分離が実装されている
- [ ] サブコンポーネントが整理されている
- [ ] act warningが解消されている
- [ ] 自動保存機能が正しく動作する
- [ ] vi.mockを使わないテストが書かれている

## 推定作業量
2日

## 依存関係
- Task 001（Provider/Contextの作成）
- Task 002（テストユーティリティ）

## 影響範囲
- EventParticipateコンポーネント
- スケジュール入力機能
- 自動保存機能

## 備考
- 既存のuseEventParticipationV2を基に改善
- 複雑な状態管理を整理
- パフォーマンスに注意