# Task 005: 認証関連コンポーネントのリファクタリング

## 概要
AuthGuard、LoginButton、UserProfileなどの認証関連コンポーネントをテスタブルな設計にリファクタリングする。
next/navigationへの直接依存を排除し、テスト可能な構造にする。

## 作業内容

### 1. AuthProviderの作成
- 認証状態の管理
- ログイン/ログアウト処理の抽象化
- NavigationProviderとの連携

### 2. useAuthフックの改善
- AuthProviderとの統合
- テスト時のモック容易性

### 3. コンポーネントのリファクタリング
- AuthGuard: NavigationProvider使用
- LoginButton: ActionsProvider使用
- UserProfile: 純粋なPresentation化

### 4. テストの書き直し
- Provider経由でのテスト
- window.locationの直接操作を排除

## 実装詳細

### AuthProvider（src/lib/providers/auth.tsx）
```typescript
import { createContext, useContext, useCallback } from "react";
import { useQuery } from "@tanstack/react-query";
import { useNavigation } from "./navigation";
import type { User } from "@/lib/effects/services/auth/schemas";

interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: Error | null;
}

interface AuthActions {
  login: (returnTo?: string) => void;
  logout: (returnTo?: string) => void;
  refresh: () => void;
}

interface AuthContextValue extends AuthState, AuthActions {}

const AuthContext = createContext<AuthContextValue | undefined>(undefined);

interface AuthProviderProps {
  children: React.ReactNode;
  value?: Partial<AuthContextValue>;
}

export function AuthProvider({ children, value }: AuthProviderProps) {
  const navigation = useNavigation();
  
  // ユーザー情報の取得
  const { data, isLoading, error, refetch } = useQuery({
    queryKey: ["auth", "user"],
    queryFn: async () => {
      const response = await fetch("/api/user/profile");
      if (response.status === 401) {
        return null;
      }
      if (!response.ok) {
        throw new Error(`Failed to fetch user: ${response.status}`);
      }
      return response.json();
    },
    retry: false,
  });
  
  // ログイン処理
  const login = useCallback((returnTo?: string) => {
    const currentPath = returnTo || navigation.params.locale 
      ? `/${navigation.params.locale}${window.location.pathname.slice(3)}`
      : window.location.pathname;
    
    navigation.push(`/auth/login?returnTo=${encodeURIComponent(currentPath)}`);
  }, [navigation]);
  
  // ログアウト処理
  const logout = useCallback((returnTo = "/") => {
    navigation.push(`/auth/logout?returnTo=${encodeURIComponent(returnTo)}`);
  }, [navigation]);
  
  const defaultValue: AuthContextValue = {
    user: data || null,
    isAuthenticated: !!data,
    isLoading,
    error: error as Error | null,
    login,
    logout,
    refresh: refetch,
    ...value, // テスト時のオーバーライド
  };
  
  return (
    <AuthContext.Provider value={defaultValue}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within AuthProvider");
  }
  return context;
}
```

### 改善されたAuthGuard（src/components/auth/AuthGuard.tsx）
```typescript
"use client";

import { useAuth } from "@/lib/providers/auth";
import { useEffect } from "react";
import { Center, Loader, Text } from "@mantine/core";

interface AuthGuardProps {
  readonly children: ReactNode;
  readonly fallback?: ReactNode;
  readonly redirectTo?: string;
}

export function AuthGuard({
  children,
  fallback,
  redirectTo = "/auth/login",
}: AuthGuardProps) {
  const { isAuthenticated, isLoading, login } = useAuth();
  
  useEffect(() => {
    if (!isLoading && !isAuthenticated) {
      const currentPath = window.location.pathname;
      login(currentPath);
    }
  }, [isAuthenticated, isLoading, login]);
  
  if (isLoading) {
    return (
      <Center mih="100vh">
        <Loader size="lg" data-testid="loading-spinner" />
      </Center>
    );
  }
  
  if (!isAuthenticated) {
    return fallback ? (
      <>{fallback}</>
    ) : (
      <Center mih="100vh">
        <Text c="dimmed">認証が必要です...</Text>
      </Center>
    );
  }
  
  return <>{children}</>;
}
```

### 改善されたLoginButton（src/components/auth/LoginButton.tsx）
```typescript
"use client";

import { Button } from "@/components/ui/Button";
import { useAuth } from "@/lib/providers/auth";
import { useTranslation } from "react-i18next";

interface LoginButtonProps {
  readonly className?: string;
}

export function LoginButton({ className }: LoginButtonProps) {
  const { isAuthenticated, isLoading, user, login, logout } = useAuth();
  const { t } = useTranslation("auth");
  
  if (isLoading) {
    return (
      <Button disabled loading className={className}>
        {t("common:ui.button.loading")}
      </Button>
    );
  }
  
  if (isAuthenticated && user) {
    return (
      <Button
        onClick={() => logout("/")}
        variant="light"
        className={className}
      >
        {t("logout.button")}
      </Button>
    );
  }
  
  return (
    <Button
      onClick={() => login()}
      className={className}
    >
      {t("login.button")}
    </Button>
  );
}
```

### UserProfileのPresentation化（src/components/auth/UserProfilePresentation.tsx）
```typescript
import { Card, Avatar, Text, Badge, Stack, Skeleton } from "@mantine/core";
import type { User } from "@/lib/effects/services/auth/schemas";

interface UserProfilePresentationProps {
  readonly user: User | null;
  readonly isLoading: boolean;
  readonly error: Error | null;
  readonly className?: string;
  readonly t: (key: string) => string;
}

export function UserProfilePresentation({
  user,
  isLoading,
  error,
  className,
  t,
}: UserProfilePresentationProps) {
  if (isLoading) {
    return (
      <Card className={className}>
        <Stack>
          <Skeleton height={60} circle />
          <Skeleton height={20} />
          <Skeleton height={16} />
        </Stack>
      </Card>
    );
  }
  
  if (error || !user) {
    return (
      <Card className={className}>
        <Text c="dimmed">{t("profile.notLoggedIn")}</Text>
      </Card>
    );
  }
  
  return (
    <Card className={className}>
      <Stack align="center">
        <Avatar src={user.picture} size="lg" radius="xl">
          {user.name?.[0]?.toUpperCase()}
        </Avatar>
        <div>
          <Text fw={500}>{user.name || t("profile.noName")}</Text>
          <Text size="sm" c="dimmed">{user.email}</Text>
        </div>
        {user.emailVerified && (
          <Badge color="green">{t("profile.emailVerified")}</Badge>
        )}
      </Stack>
    </Card>
  );
}
```

### テスト（src/components/auth/AuthGuard.test.tsx）
```typescript
import { describe, it, expect } from "vitest";
import { render, screen, waitFor } from "@testing-library/react";
import { renderWithProviders } from "@/test/providers";
import { AuthGuard } from "./AuthGuard";

describe("AuthGuard", () => {
  it("ローディング中はスピナーを表示", () => {
    renderWithProviders(
      <AuthGuard>
        <div>保護されたコンテンツ</div>
      </AuthGuard>,
      {
        auth: {
          isLoading: true,
          isAuthenticated: false,
          user: null,
        },
      }
    );
    
    expect(screen.getByTestId("loading-spinner")).toBeInTheDocument();
    expect(screen.queryByText("保護されたコンテンツ")).not.toBeInTheDocument();
  });
  
  it("認証済みの場合は子要素を表示", () => {
    renderWithProviders(
      <AuthGuard>
        <div>保護されたコンテンツ</div>
      </AuthGuard>,
      {
        auth: {
          isLoading: false,
          isAuthenticated: true,
          user: { id: "user123", name: "テストユーザー" },
        },
      }
    );
    
    expect(screen.getByText("保護されたコンテンツ")).toBeInTheDocument();
  });
  
  it("未認証の場合はlogin関数を呼ぶ", () => {
    const mockLogin = vi.fn();
    
    renderWithProviders(
      <AuthGuard>
        <div>保護されたコンテンツ</div>
      </AuthGuard>,
      {
        auth: {
          isLoading: false,
          isAuthenticated: false,
          user: null,
          login: mockLogin,
        },
      }
    );
    
    expect(mockLogin).toHaveBeenCalled();
    expect(screen.getByText("認証が必要です...")).toBeInTheDocument();
  });
});
```

## 受け入れ条件
- [ ] AuthProviderが実装されている
- [ ] 認証関連コンポーネントがProvider経由で動作
- [ ] window.locationの直接操作が排除されている
- [ ] vi.mockを使わないテストが書かれている
- [ ] 既存の機能が維持されている

## 推定作業量
1.5日

## 依存関係
- Task 001（Provider/Contextの作成）
- Task 002（テストユーティリティ）

## 影響範囲
- すべての認証関連コンポーネント
- 認証フロー全体
- 認証に依存するコンポーネント

## 備考
- 既存のAPIとの互換性を保つ
- セキュリティに注意
- パフォーマンスへの影響を最小限に